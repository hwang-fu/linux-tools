<!-- * * * * * * * * * * * * * * -->
<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>CURL</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">
    <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
            data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    html {
        scroll-behavior: smooth;
    }

    .back-to-top {
        position: fixed;
        right: 20px;
        bottom: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #333;
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        font-size: 22px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        opacity: 0.75;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 999;
    }

    .back-to-top:hover {
        opacity: 1;
        transform: translateY(-2px);
    }

    .nav-icon {
        width: 18px;
        height: 18px;
        object-fit: contain;
        vertical-align: middle;
        margin-left: 0.3rem;
    }

    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .comment {
        color: grey;
    }

    .token.keyword {
        font-weight: 500;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.4;
    }

    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }

    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
</head>
<!-- * * * * * * * * * * * * * * -->
<body>
<a href="#" class="back-to-top" aria-label="Back to top">
    &#8593;
</a>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<hr/>
<nav id="toc" style="margin-bottom: 2rem;">
    <ul style="line-height: 1.8;">
        <li><a href="#curl-introduction">Introduction</a></li>
        <li><a href="#curl-common-options">Common Options</a></li>
    </ul>
</nav>
<hr/>
<!-- * * * * * * * * * * * * * * -->


<!-- * * * * * * * * * * * * * * -->
<h3 id="curl-introduction">The Command-Line URL Tool</h3>
<ol>

    <li><b>What Is curl?</b></li>
    <br/>
    <ul>
        <li><code>curl</code> (short for <b>Client URL</b>) is a powerful command-line tool to:
            <ul>
                <li>send HTTP(S) requests,</li>
                <li>download or upload files,</li>
                <li>interact with APIs,</li>
                <li>debug network problems.</li>
            </ul>
        </li>
        <br/>
        <li>It supports many protocols:
            <ul>
                <li>HTTP, HTTPS</li>
                <li>FTP, FTPS, SFTP</li>
                <li>SCP, SMTP, POP3, IMAP, and more (depending on build)</li>
            </ul>
        </li>
        <br/>
        <li>Typical use cases:
            <ul>
                <li>Checking a website response</li>
                <li>Calling a REST API from the terminal</li>
                <li>Downloading files</li>
                <li>Sending form data or JSON payloads</li>
                <li>Testing authentication and headers</li>
            </ul>
        </li>
        <br/>
        <li><code>curl</code> is installed by default on many Linux/macOS systems; Windows has official builds too.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Syntax</b></li>
    <br/>
    <ul>
        <li>The simplest form:</li>
    </ul>

<pre><code class="language-bash line-numbers">curl &lt;options&gt; &lt;URL&gt;</code></pre>

    <br/>
    <ul>
        <li>Examples:</li>
    </ul>

<pre><code class="language-bash line-numbers"># Fetch a web page and print to terminal (stdout)
curl https://example.com

# Fetch over HTTP
curl http://example.com</code></pre>

    <br/>
    <ul>
        <li>If you provide no options, <code>curl</code>:
            <ul>
                <li>sends an HTTP <code>GET</code> request,</li>
                <li>prints the response body to the terminal.</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Saving Output to a File</b></li>
    <br/>
    <ul>
        <li>By default, the response body is printed to the screen.</li>
        <li>To save it to a file, you have two common options:</li>
    </ul>

<pre><code class="language-bash line-numbers"># 1) Shell redirection
curl https://example.com &gt; page.html

# 2) Let curl decide file name from URL with -O (uppercase O)
curl -O https://example.com/file.zip

# 3) Save to a chosen file name with -o (lowercase o)
curl -o mypage.html https://example.com</code></pre>

    <br/>
    <ul>
        <li><code>-O</code>: use the file name from the URL.</li>
        <li><code>-o</code>: explicitly specify the file name.</li>
    </ul>
    <br/><br/>


    <li><b>Seeing Response Headers</b></li>
    <br/>
    <ul>
        <li>Sometimes you want to see HTTP headers (status code, content type, etc.).</li>
        <li>Use <code>-i</code> (include headers in output):</li>
    </ul>

<pre><code class="language-bash line-numbers">curl -i https://example.com</code></pre>

    <br/>
    <ul>
        <li>This prints:</li>
        <ul>
            <li>status line (e.g. <code>HTTP/1.1 200 OK</code>)</li>
            <li>response headers</li>
            <li>blank line</li>
            <li>response body</li>
        </ul>
        <li>Use <code>-I</code> (uppercase i) to fetch <b>only</b> the headers via an HTTP <code>HEAD</code> request:</li>
    </ul>

<pre><code class="language-bash line-numbers">curl -I https://example.com</code></pre>

    <br/><br/>


    <li><b>Following Redirects</b></li>
    <br/>
    <ul>
        <li>Many sites redirect (e.g. from <code>http</code> to <code>https</code>).</li>
        <li>By default, <code>curl</code> does <b>not</b> follow redirects.</li>
        <li>Use <code>-L</code> to follow them:</li>
    </ul>

<pre><code class="language-bash line-numbers">curl -L http://example.com</code></pre>

    <br/>
    <ul>
        <li>Now <code>curl</code> will automatically follow the <code>Location</code> headers until it reaches the final URL.</li>
    </ul>
    <br/><br/>


    <li><b>Adding Custom Headers</b></li>
    <br/>
    <ul>
        <li>APIs often require custom HTTP headers (e.g. auth tokens, content type).</li>
        <li>Use <code>-H</code> (or <code>--header</code>) to add a header:</li>
    </ul>

<pre><code class="language-bash line-numbers">curl -H "X-My-Header: hello" https://example.com

# Multiple headers:
curl \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Accept: application/json" \
  https://api.example.com/data</code></pre>

    <br/><br/>


    <li><b>Sending Query Parameters</b></li>
    <br/>
    <ul>
        <li>Query parameters are simply part of the URL:</li>
    </ul>

<pre><code class="language-bash line-numbers">curl "https://example.com/search?q=haskell&amp;page=2"</code></pre>

    <br/>
    <ul>
        <li>Be sure to quote the URL if it contains <code>&amp;</code> so the shell does not interpret it.</li>
    </ul>
    <br/><br/>


    <li><b>HTTP Methods: GET, POST, PUT, DELETE, ...</b></li>
    <br/>
    <ul>
        <li>By default, <code>curl</code> sends a <code>GET</code> request.</li>
        <li>Use <code>-X</code> (or <code>--request</code>) to specify a method explicitly:</li>
    </ul>

<pre><code class="language-bash line-numbers"># Explicit GET
curl -X GET https://example.com

# DELETE
curl -X DELETE https://api.example.com/items/123</code></pre>

    <br/>
    <ul>
        <li>For <b>POST/PUT</b>, you usually combine with <code>-d</code> (send data).</li>
    </ul>
    <br/><br/>


    <li><b>Sending Form Data</b> (<code>application/x-www-form-urlencoded</code>)</li>
    <br/>
    <ul>
        <li>Classic HTML forms send data encoded like <code>key=value&amp;key2=value2</code>.</li>
        <li>Use <code>-d</code> (or <code>--data</code>) to send such data:</li>
    </ul>

<pre><code class="language-bash line-numbers">curl -X POST https://example.com/login \
  -d "username=alice&amp;password=secret"</code></pre>

    <br/>
    <ul>
        <li>When you use <code>-d</code> without <code>-X</code>, <code>curl</code> automatically uses <code>POST</code> and sets an appropriate content type.</li>
        <li>To send multiple fields:</li>
    </ul>

<pre><code class="language-bash line-numbers">curl https://example.com/form \
  -d "field1=value1" \
  -d "field2=value2"</code></pre>

    <br/><br/>


    <li><b>Sending JSON Data</b></li>
    <br/>
    <ul>
        <li>Modern APIs typically use JSON.</li>
        <li>When sending JSON:
            <ul>
                <li>set the <code>Content-Type</code> header,</li>
                <li>provide JSON payload via <code>-d</code>.</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-bash line-numbers">curl -X POST https://api.example.com/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice", "age": 30}'</code></pre>

    <br/>
    <ul>
        <li>If your shell uses quotes differently, be careful to escape them properly.</li>
    </ul>
    <br/><br/>


    <li><b>Uploading Files</b></li>
    <br/>
    <ul>
        <li>Use <code>-F</code> (form) to upload files with multipart/form-data (like HTML forms):</li>
    </ul>

<pre><code class="language-bash line-numbers">curl -X POST https://example.com/upload \
  -F "file=@/path/to/local/file.txt"</code></pre>

    <br/>
    <ul>
        <li>The <code>@</code> prefix tells <code>curl</code> to read the contents from a file.</li>
        <li>You can upload multiple fields/files:</li>
    </ul>

<pre><code class="language-bash line-numbers">curl https://example.com/upload \
  -F "description=My file" \
  -F "file=@/path/to/file.txt"</code></pre>

    <br/><br/>


    <li><b>Authentication</b></li>
    <br/>
    <ul>
        <li><b>Basic Auth</b>:</li>
    </ul>

<pre><code class="language-bash line-numbers">curl -u "username:password" https://api.example.com/secure</code></pre>

    <br/>
    <ul>
        <li><code>-u</code> adds the appropriate <code>Authorization: Basic ...</code> header.</li>
        <li><b>Bearer Token (common for APIs)</b>:</li>
    </ul>

<pre><code class="language-bash line-numbers">curl https://api.example.com/data \
  -H "Authorization: Bearer YOUR_TOKEN_HERE"</code></pre>

    <br/><br/>


    <li><b>HTTPS and Certificates</b></li>
    <br/>
    <ul>
        <li>When using <code>https://</code>, <code>curl</code> verifies the server’s TLS certificate.</li>
        <li>For debugging self-signed or local dev setups, you can (temporarily) skip verification:</li>
    </ul>

<pre><code class="language-bash line-numbers">curl -k https://self-signed.example.local</code></pre>

    <br/>
    <ul>
        <li><b>Warning:</b> <code>-k</code> (or <code>--insecure</code>) disables certificate verification and is not recommended for production.</li>
        <li>Better: point <code>curl</code> to a custom CA bundle with <code>--cacert</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Verbose and Debugging Output</b></li>
    <br/>
    <ul>
        <li>Use <code>-v</code> (<code>--verbose</code>) to debug requests:</li>
    </ul>

<pre><code class="language-bash line-numbers">curl -v https://example.com</code></pre>

    <br/>
    <ul>
        <li>This prints:
            <ul>
                <li>request line and headers,</li>
                <li>response headers,</li>
                <li>TLS handshake info (for HTTPS).</li>
            </ul>
        </li>
        <li>Use <code>--trace</code> and <code>--trace-ascii</code> for even more low-level details.</li>
    </ul>
    <br/><br/>


    <li><b>Setting User-Agent and Other Common Options</b></li>
    <br/>
    <ul>
        <li>Some servers behave differently based on the User-Agent header.</li>
        <li>Set it with <code>-A</code> (or <code>--user-agent</code>):</li>
    </ul>

<pre><code class="language-bash line-numbers">curl -A "MyTestClient/1.0" https://example.com</code></pre>

    <br/>
    <ul>
        <li>Other useful flags:
            <ul>
                <li><code>--compressed</code> – ask server for compressed response (gzip, etc.)</li>
                <li><code>--max-time &lt;seconds&gt;</code> – limit total time of request</li>
                <li><code>--connect-timeout &lt;seconds&gt;</code> – limit connection setup time</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Rate Limiting and Repeated Requests</b></li>
    <br/>
    <ul>
        <li>For simple repeated calls with pauses, combine <code>curl</code> with shell tools:</li>
    </ul>

<pre><code class="language-bash line-numbers"># Call an endpoint every 5 seconds (Ctrl-C to stop)
while true; do
  curl -s https://example.com/health
  echo
  sleep 5
done</code></pre>

    <br/>
    <ul>
        <li><code>-s</code> (silent) hides progress meter and errors (show only output), useful when scripting.</li>
    </ul>
    <br/><br/>


    <li><b>Getting Help and Manual</b></li>
    <br/>
    <ul>
        <li>To see a quick summary of options:</li>
    </ul>

<pre><code class="language-bash line-numbers">curl --help</code></pre>

    <br/>
    <ul>
        <li>For the full manual (very detailed):</li>
    </ul>

<pre><code class="language-bash line-numbers">man curl        # on Unix-like systems
curl --manual   # portable way</code></pre>

    <br/><br/>
</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="curl-common-options">Common Options</h3>
<ol>

    <li><b>Basic Output &amp; File Handling Options</b></li>
    <ul>
        <br/>
        <li>These options control where the response goes and how it is displayed.</li>
        <br/>
    </ul>

    <table>
        <tr>
            <th>Option</th>
            <th>Description</th>
            <th>Example</th>
        </tr>

        <tr>
            <td><code>-h</code>, <code>--help</code></td>
            <td>Show a short help summary of available options.</td>
            <td><code>curl --help</code></td>
        </tr>

        <tr>
            <td><code>-V</code>, <code>--version</code></td>
            <td>Show version info and supported protocols/features.</td>
            <td><code>curl --version</code></td>
        </tr>

        <tr>
            <td><code>-s</code>, <code>--silent</code></td>
            <td>Silent mode: no progress meter or error messages (only body on stdout).</td>
            <td><code>curl -s https://example.com</code></td>
        </tr>

        <tr>
            <td><code>-S</code>, <code>--show-error</code></td>
            <td>Show errors even when <code>-s</code> is used (good for scripts).</td>
            <td><code>curl -sS https://example.com</code></td>
        </tr>

        <tr>
            <td><code>-o &lt;file&gt;</code></td>
            <td>Write response body to the given file name.</td>
            <td><code>curl -o page.html https://example.com</code></td>
        </tr>

        <tr>
            <td><code>-O</code> (capital O)</td>
            <td>Save to a file named after the remote URL&apos;s path (remote file name).</td>
            <td><code>curl -O https://example.com/file.zip</code></td>
        </tr>

        <tr>
            <td><code>-L</code>, <code>--location</code></td>
            <td>Follow HTTP redirects (3xx responses) automatically.</td>
            <td><code>curl -L http://example.com</code></td>
        </tr>

        <tr>
            <td><code>-#</code></td>
            <td>Display a nice progress bar instead of the default meter.</td>
            <td><code>curl -# -O https://example.com/big.iso</code></td>
        </tr>

        <tr>
            <td><code>-C -</code></td>
            <td>Resume a previous download (if server supports HTTP range requests).</td>
            <td><code>curl -C - -O https://example.com/big.iso</code></td>
        </tr>
    </table>
    <br/><br/>


    <li><b>HTTP Request &amp; Response Control</b></li>
    <br/>
    <ul>
        <li>These options control the HTTP method and what parts of the response you see.</li>
    </ul>
    <br/>

    <table>
        <tr>
            <th>Option</th>
            <th>Description</th>
            <th>Example</th>
        </tr>

        <tr>
            <td><code>-X &lt;METHOD&gt;</code>, <code>--request &lt;METHOD&gt;</code></td>
            <td>Explicitly specify HTTP method: GET, POST, PUT, DELETE, etc.</td>
            <td><code>curl -X DELETE https://api.example.com/items/123</code></td>
        </tr>

        <tr>
            <td><code>-i</code>, <code>--include</code></td>
            <td>Include HTTP response headers in the output (before body).</td>
            <td><code>curl -i https://example.com</code></td>
        </tr>

        <tr>
            <td><code>-I</code>, <code>--head</code></td>
            <td>Send an HTTP HEAD request (get only headers, no body).</td>
            <td><code>curl -I https://example.com</code></td>
        </tr>

        <tr>
            <td><code>--http1.1</code>, <code>--http2</code></td>
            <td>Force HTTP/1.1 or HTTP/2 for the request (if supported).</td>
            <td><code>curl --http2 https://example.com</code></td>
        </tr>

        <tr>
            <td><code>--compressed</code></td>
            <td>Request a compressed response (gzip, deflate) and automatically decompress it.</td>
            <td><code>curl --compressed https://example.com</code></td>
        </tr>

        <tr>
            <td><code>--limit-rate &lt;speed&gt;</code></td>
            <td>Limit transfer speed (e.g. <code>200k</code>, <code>2M</code>).</td>
            <td><code>curl --limit-rate 200k -O https://example.com/file.zip</code></td>
        </tr>
    </table>
    <br/><br/>


    <li><b>Sending Data: Forms, JSON, Raw Bodies</b></li>
    <br/>
    <ul>
        <li>These options are central when working with REST APIs or HTML forms.</li>
    </ul>
    <br/>

    <table>
        <tr>
            <th>Option</th>
            <th>Description</th>
            <th>Example</th>
        </tr>

        <tr>
            <td><code>-d &lt;data&gt;</code>, <code>--data &lt;data&gt;</code></td>
            <td>
                Send a request body. Defaults to <code>application/x-www-form-urlencoded</code> and switches method to POST if not set.
            </td>
            <td><code>curl -d "user=alice&amp;pass=secret" https://example.com/login</code></td>
        </tr>

        <tr>
            <td><code>--data-urlencode &lt;data&gt;</code></td>
            <td>Like <code>-d</code>, but URL-encodes the given data (safe for special characters).</td>
            <td><code>curl --data-urlencode "q=haskell &amp; monads" https://example.com/search</code></td>
        </tr>

        <tr>
            <td><code>--data-binary &lt;data&gt;</code></td>
            <td>Send data exactly as given, without stripping newlines or treating <code>@</code> specially.</td>
            <td><code>curl --data-binary "@/path/to/raw.bin" https://example.com/upload</code></td>
        </tr>

        <tr>
            <td><code>-F &lt;name=@file&gt;</code>, <code>--form</code></td>
            <td>Send multipart/form-data (file upload) like an HTML form.</td>
            <td><code>curl -F "file=@/path/to/photo.jpg" https://example.com/upload</code></td>
        </tr>

        <tr>
            <td><code>-G</code>, <code>--get</code></td>
            <td>Send the data as query parameters in a GET request instead of POST.</td>
            <td><code>curl -G -d "q=haskell" -d "page=2" https://example.com/search</code></td>
        </tr>
    </table>
    <br/><br/>


    <li><b>Headers &amp; Authentication Options</b></li>
    <br/>
    <ul>
        <li>For APIs and protected resources, you often need to set custom headers or credentials.</li>
    </ul>
    <br/>

    <table>
        <tr>
            <th>Option</th>
            <th>Description</th>
            <th>Example</th>
        </tr>

        <tr>
            <td><code>-H &lt;header&gt;</code>, <code>--header &lt;header&gt;</code></td>
            <td>Add a custom HTTP header. Can be used multiple times.</td>
            <td><code>curl -H "Accept: application/json" https://api.example.com/data</code></td>
        </tr>

        <tr>
            <td><code>-A &lt;agent&gt;</code>, <code>--user-agent &lt;agent&gt;</code></td>
            <td>Set a custom User-Agent string.</td>
            <td><code>curl -A "MyClient/1.0" https://example.com</code></td>
        </tr>

        <tr>
            <td><code>-u &lt;user:pass&gt;</code>, <code>--user &lt;user:pass&gt;</code></td>
            <td>Use HTTP Basic authentication (sends Authorization: Basic ... header).</td>
            <td><code>curl -u "alice:secret" https://api.example.com/me</code></td>
        </tr>

        <tr>
            <td><code>--oauth2-bearer &lt;token&gt;</code></td>
            <td>Send OAuth2 Bearer token as Authorization header.</td>
            <td><code>curl --oauth2-bearer YOUR_TOKEN https://api.example.com/data</code></td>
        </tr>

        <tr>
            <td><code>--referer &lt;url&gt;</code></td>
            <td>Set the HTTP Referer header.</td>
            <td><code>curl --referer "https://google.com" https://example.com</code></td>
        </tr>

        <tr>
            <td><code>-b &lt;file or data&gt;</code>, <code>--cookie</code></td>
            <td>Send cookies from a file or directly as a string (client side).</td>
            <td><code>curl -b "session=abcd1234" https://example.com</code></td>
        </tr>

        <tr>
            <td><code>-c &lt;file&gt;</code>, <code>--cookie-jar</code></td>
            <td>Save cookies to a file after the request (for reuse later).</td>
            <td><code>curl -c cookies.txt https://example.com/login</code></td>
        </tr>
    </table>
    <br/><br/>


    <li><b>TLS / HTTPS &amp; Security Options</b></li>
    <br/>
    <ul>
        <li>These options affect how <code>curl</code> handles HTTPS connections and certificates.</li>
    </ul>
    <br/>

    <table>
        <tr>
            <th>Option</th>
            <th>Description</th>
            <th>Example</th>
        </tr>

        <tr>
            <td><code>-k</code>, <code>--insecure</code></td>
            <td>Skip certificate verification (accept self-signed/invalid certs). Useful for local dev, <b>not</b> recommended in production.</td>
            <td><code>curl -k https://localhost:8443</code></td>
        </tr>

        <tr>
            <td><code>--cacert &lt;file&gt;</code></td>
            <td>Use a custom CA certificate file to verify the server.</td>
            <td><code>curl --cacert myCA.pem https://internal.example.com</code></td>
        </tr>

        <tr>
            <td><code>--cert &lt;cert&gt;</code></td>
            <td>Provide a client certificate (for mutual TLS authentication).</td>
            <td><code>curl --cert mycert.pem https://secure.example.com</code></td>
        </tr>

        <tr>
            <td><code>--key &lt;key&gt;</code></td>
            <td>Private key corresponding to <code>--cert</code>, if stored separately.</td>
            <td><code>curl --cert client.crt --key client.key https://secure.example.com</code></td>
        </tr>

        <tr>
            <td><code>--tlsv1.2</code>, <code>--tlsv1.3</code></td>
            <td>Force a specific TLS version (useful for debugging or strict policies).</td>
            <td><code>curl --tlsv1.2 https://example.com</code></td>
        </tr>
    </table>
    <br/><br/>


    <li><b>Debugging &amp; Performance Options</b></li>
    <br/>
    <ul>
        <li>These options help when you are inspecting or tuning HTTP requests.</li>
    </ul>
    <br/>

    <table>
        <tr>
            <th>Option</th>
            <th>Description</th>
            <th>Example</th>
        </tr>

        <tr>
            <td><code>-v</code>, <code>--verbose</code></td>
            <td>Verbose mode: show request headers, response headers, and connection info.</td>
            <td><code>curl -v https://example.com</code></td>
        </tr>

        <tr>
            <td><code>--trace &lt;file&gt;</code></td>
            <td>Write a very detailed trace of everything curl does into a file (binary safe).</td>
            <td><code>curl --trace trace.log https://example.com</code></td>
        </tr>

        <tr>
            <td><code>--trace-ascii &lt;file&gt;</code></td>
            <td>Like <code>--trace</code>, but easier to read (ASCII only).</td>
            <td><code>curl --trace-ascii debug.txt https://example.com</code></td>
        </tr>

        <tr>
            <td><code>--max-time &lt;seconds&gt;</code></td>
            <td>Limit the total allowed time for the whole transfer.</td>
            <td><code>curl --max-time 10 https://slow.example.com</code></td>
        </tr>

        <tr>
            <td><code>--connect-timeout &lt;seconds&gt;</code></td>
            <td>Limit how long curl waits to establish the connection.</td>
            <td><code>curl --connect-timeout 5 https://example.com</code></td>
        </tr>

        <tr>
            <td><code>--retry &lt;n&gt;</code></td>
            <td>Automatically retry the request up to <code>n</code> times on transient errors.</td>
            <td><code>curl --retry 3 https://flaky.example.com</code></td>
        </tr>

        <tr>
            <td><code>--retry-delay &lt;seconds&gt;</code></td>
            <td>Wait this many seconds between retries.</td>
            <td><code>curl --retry 3 --retry-delay 5 https://flaky.example.com</code></td>
        </tr>
    </table>
    <br/><br/>


    <li><b>Common Option Combinations (Mini Cheat Sheet)</b></li>
    <br/>
    <ul>
        <li>Some very common real-world patterns:</li>
    </ul>

<pre><code class="language-bash line-numbers"># 1) Simple JSON API GET request with custom header
curl -sS -H "Accept: application/json" https://api.example.com/users

# 2) JSON POST with Bearer token
curl -sS -X POST https://api.example.com/users \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{"name":"Alice","age":30}'

# 3) Follow redirects, save result to file
curl -L -o page.html https://example.com

# 4) Debug a failing HTTPS endpoint (verbose + do not verify cert)
curl -v -k https://localhost:8443

# 5) Upload a file with additional form data
curl -F "file=@/path/to/file.txt" \
     -F "description=My upload" \
     https://example.com/upload</code></pre>
    <br/><br/>

</ol>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
<!-- * * * * * * * * * * * * * * -->

<footer>
    <p>&copy; 2025 Hwangfucius. All rights reserved.</p>
</footer>
</body>
<!-- * * * * * * * * * * * * * * -->
</html>
<!-- * * * * * * * * * * * * * * -->
