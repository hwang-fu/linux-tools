<!-- * * * * * * * * * * * * * * -->

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.css">
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-core.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/autoloader/prism-autoloader.min.js"
        data-prismjs-autoloader-path="https://cdn.jsdelivr.net/npm/prismjs/components/"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
    table {
        border-collapse: collapse;
        width: 100%;
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", serif;
        font-size: 14px;
    }

    th {
        background-color: #f5f5f5;
        text-align: left;
        font-weight: 600;
    }

    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
    }

    tr:nth-child(even) {
        background-color: #fafafa;
    }

    tr:hover {
        background-color: #f0f8ff;
    }

    .hl-red {
        background-color: red;
    }

    .hl-green {
        background-color: green;
    }

    .hl-blue {
        background-color: blue;
    }

    .hl-yellow {
        background-color: yellow;
    }

    .hl-red-bg {
        background-color: red;
    }

    .hl-green-bg {
        background-color: green;
    }

    .hl-blue-bg {
        background-color: blue;
    }

    .hl-yellow-bg {
        background-color: yellow;
    }

    .hl-red-fg {
        color: red;
    }

    .hl-green-fg {
        color: green;
    }

    .hl-blue-fg {
        color: blue;
    }

    .hl-yellow-fg {
        color: yellow;
    }

    .hl-purple-fg {
        color: purple;
    }

    .red-underline {
        text-decoration-line: underline;
        text-decoration-color: red;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
    }

    .comment {
        color: grey;
    }

    body {
        font-family: "KaiTi", "楷体", "STKaiti", "Kaiti SC", "Times New Roman", Georgia, serif;
        font-variant-ligatures: none;
    }

    ul > li {
        list-style-type: disc;
    }

    code {
        color: #24292e;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .375rem;
        padding: .15rem .35rem;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.4;
    }


    pre {
        margin: 1rem 0;
        padding: .8rem 1rem;
        background-color: #f6f8fa;
        border: 1px solid #d0d7de;
        border-radius: .5rem;
        overflow: auto;
        tab-size: 4;
    }


    pre code {
        display: block;
        padding: 0;
        background: transparent;
        border: 0;
        color: #24292e;
        font-family: "FiraCode Nerd Font", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        white-space: pre;
    }
</style>
<!-- * * * * * * * * * * * * * * -->



<!-- * * * * * * * * * * * * * * -->
<script>
</script>
<!-- * * * * * * * * * * * * * * -->


<hr/>
<h1>Git</h1>
<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="git-conventional-commits">Conventional Commits</h3>
<ol>
<table>
    <thead>
        <tr>
            <th>Type</th>
            <th>Meaning</th>
            <th>Usage</th>
            <th>SemVer Impact</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>feat</b></td>
            <td>A new user-visible feature</td>
            <td>New endpoint, new UI component, CLI option, etc.</td>
            <td>Minor (or Major if breaking)</td>
            <td><code>feat(search): add fuzzy matching</code></td>
        </tr>
        <tr>
            <td><b>fix</b></td>
            <td>A bug fix</td>
            <td>Correct wrong logic, null checks, crash fixes, etc.</td>
            <td>Patch</td>
            <td><code>fix(parser): handle CRLF line endings</code></td>
        </tr>
        <tr>
            <td><b>docs</b></td>
            <td>Documentation only</td>
            <td>README, API docs, comments</td>
            <td>None</td>
            <td><code>docs(readme): add install steps for openSUSE</code></td>
        </tr>
        <tr>
            <td><b>style</b></td>
            <td>No logic change, formatting</td>
            <td>whitespace, semicolons, formatter</td>
            <td>None</td>
            <td><code>style: run clang-format</code></td>
        </tr>
        <tr>
            <td><b>refactor</b></td>
            <td>Code change that neither fixes a bug nor adds a feature</td>
            <td>rename, restructure, extract function</td>
            <td>None (unless breaking)</td>
            <td><code>refactor(ui): split dashboard into widgets</code></td>
        </tr>
        <tr>
            <td><b>perf</b></td>
            <td>Performance improvements</td>
            <td>reduce allocations, optimize query</td>
            <td>Path (or minor if user-facing behavior)</td>
            <td><code>perf(scanner): cut token allocs by 49%</code></td>
        </tr>
        <tr>
            <td><b>test</b></td>
            <td>Add / modify tests</td>
            <td>unit / integration/ regression tests</td>
            <td>None</td>
            <td><code>test: add case for empty CSV</code></td>
        </tr>
        <tr>
            <td><b>build</b></td>
            <td>Build system changes</td>
            <td>make / cmake / gradle compiler flags</td>
            <td>None</td>
            <td><code>build(cmake): cache vcpkg artifacts</code></td>
        </tr>
        <tr>
            <td><b>ci</b></td>
            <td>Continuoous integration</td>
            <td>GitHub Actions, Jenkins, pipelines</td>
            <td>None</td>
            <td><code>ci: add matrix for macOS</code></td>
        </tr>
        <tr>
            <td><b>chore</b></td>
            <td>Housekeeping</td>
            <td>bump tooling, rename files, no src change</td>
            <td>None</td>
            <td><code>chore: update editorconfig</code></td>
        </tr>
        <tr>
            <td><b>revert</b></td>
            <td>Revert a previous commit</td>
            <td>rollback with reference</td>
            <td>Reverts prior impact</td>
            <td><code>revert: feat(search) add fuzzy matching</code></td>
        </tr>
        <tr>
            <td><b>deps</b></td>
            <td>Dependency updates</td>
            <td>bump libs, lockfiles</td>
            <td>None / Patch (security fixes often Patch)</td>
            <td><code>deps: bump lodash to 4.17.21</code></td>
        </tr>
        <tr>
            <td><b>security</b></td>
            <td>Security fixes</td>
            <td>vulns, hardening</td>
            <td>Path (Major if breaking)</td>
            <td><code>security: sanitize user input</code></td>
        </tr>
    </tbody>
</table>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="git-branches">Branches</h3>
<ol>
    <li>In Git, a <u>branch</u> is simply a pointer (a reference) to a specific commit in the repo history.<br/>
        It allows you to develop features, fix bugs, or experiment independently from the main codebase.</li>
    <br/>
    <br/>
    <li>When you create a new Git repository, Git starts with a default branch (it is usually the branch that holds your production-ready code),<br/>
        commonly named:</li>
    <ul>
        <li><code>main</code> (modern default)</li>
        <li><code>master</code> (legacy / default in old versions)</li>
    </ul>
    <br/>
    <br/>
    <li>A new branch starts at the current commit and lets you diverge from there:</li>
<pre><code class="language-bash line-numbers">git checkout -b feature/new-api

# or (modern syntax)
git switch -c feature/new-api
</code></pre>
    This creates a new branch named feature/new-api starting from wherever you currently are (<b>HEAD</b>), and switches you to it.
    <br/>
    <br/>
    <br/>
    <li><b>HEAD</b> is Git's special pointer to your current branch or commit.<br/>
        When you checkout a branch, <b>HEAD</b> points to that branch.<br/>
        When you're in a detached <b>HEAD</b> state (e.g., on a specific commit), <b>HEAD</b> points directly to the commit hash.</li>
    <br/>
    <br/>
    <li>After a feature is merged, you often want to delete the branch:</li>
<pre><code class="language-bash line-numbers">git branch -d feature/new-ui                # Local
git push origin --delete feature/new-ui     # Remote
</code></pre>
    <br/>
    <br/>
    <li>Push a new branch to GitHub: <code>git push -u origin feature/x</code></li>
    <br/>
    <br/>
    <li>Pull a remote branch: <code>git fetch</code> then <code>git checkout feature/x</code></li>
    <br/>
    <br/>
    <li>List Branches:</li>
<pre><code class="language-bash line-numbers">git branch          # local
git branch -r       # remote
git branch -a       # all
</code></pre>
    <br/>
    <br/>
    <li>General format of git branch naming:</li>
<pre><code class="language-bash line-numbers">&lt;type&gt;/&lt;short-description&gt;
&lt;type&gt;/&lt;issue-number&gt;-&lt;short-description&gt;
</code></pre>
    <br/>
    <br/>
    <li>Links youor current local branch to the remote-tracking branch:</li>
<pre><code class="language-bash line-numbers"># assuming you're in the local branch "feature/generic",
# and you wish to link it with the "feature/generic" in the origin remote repo.
git branch --set-upstream-to=origin/feature/generic
</code></pre>
    <br/>
    <br/>
    <li>Push a local branch to the remote and set upstream.</li>
<pre><code class="language-bash line-numbers">git checkout -b &lt;branch-name&gt;
git push -u origin &lt;branch-name&gt;
</code></pre>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="git-three-stages">The Three Stages of Git</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Git is a distributed version control system that tracks changes to files over time.</li>
        <br/>
        <li>Every file in your Git repository is always in one of three main stages:</li>
        <ul>
            <li><u>Working Directory</u>: your actual files on disk</li>
            <li><u>Staging Area</u> (Index): files prepared for commit</li>
            <li><u>Repository</u>: committed snapshots stored in <code>.git/</code></li>
        </ul>
    </ul>
    <br/><br/>


    <li><b>The Three Stages Overview</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Stage</th>
                <th>Description</th>
                <th>Example Files</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Working Directory</td>
                <td>Files you are editing right now</td>
                <td><code>modified.txt</code></td>
            </tr>
            <tr>
                <td>Staging Area (Index)</td>
                <td>Files marked for the next commit</td>
                <td><code>added.txt</code></td>
            </tr>
            <tr>
                <td>Repository</td>
                <td>Committed snapshots stored permanently</td>
                <td><code>.git/objects</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>1. Working Directory (Untracked or Modified State)</b></li>
    <br/>
    <ul>
        <li>This is where you create, edit, delete, and modify files.</li>
        <li>The working directory shows:
            <ul>
                <li><u>untracked files</u>: Git doesn't know about them</li>
                <li><u>modified files</u>: Git knows them but they were changed</li>
                <li><u>deleted files</u>: files removed but not staged yet</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-bash line-numbers">git status
</code></pre>

<pre><code class="language-bash">Untracked files:
  newfile.txt

Changes not staged for commit:
  modified: README.md
</code></pre>

    <br/>
    <ul>
        <li>The working directory contains files before they are staged.</li>
        <li>To move files to the next stage, you must stage them.</li>
    </ul>
    <br/><br/>


    <li><b>2. Staging Area (Index)</b></li>
    <br/>
    <ul>
        <li>The staging area is a temporary holding place for files you want to include in your next commit.</li>
        <li>You stage files manually using:</li>
    </ul>

<pre><code class="language-bash line-numbers">git add filename
git add .
</code></pre>

    <br/>
    <ul>
        <li>After staging, changes move from the working directory to the index:</li>
    </ul>

<pre><code class="language-bash line-numbers">git status
</code></pre>

<pre><code class="language-bash">Changes to be committed:
  new file:   newfile.txt
  modified:   README.md
</code></pre>

    <br/>
    <ul>
        <li>Only staged files are included in the next commit.</li>
        <li>The staging area allows building commits intentionally and selectively.</li>
    </ul>

    <br/><br/>


    <li><b>3. Repository (Local Git Database)</b></li>
    <br/>
    <ul>
        <li>Once you commit, changes are saved permanently into the local Git repository at <code>.git/</code>.</li>
        <li>Committed files become part of Git history.</li>
        <li>Use:</li>
    </ul>

<pre><code class="language-bash line-numbers">git commit -m "message"
</code></pre>

    <br/>
    <ul>
        <li>Commits move staged files into the repository:</li>
    </ul>

<pre><code class="language-bash line-numbers">git log --oneline
</code></pre>

<pre><code class="language-bash">a4c71f1  Add README and initial setup
</code></pre>

    <br/>
    <ul>
        <li>Files in the repository are versioned and safe.</li>
        <li>Undoing or retrieving them is easy.</li>
    </ul>
    <br/><br/>


    <li><b>The Full Git Workflow with Example</b></li>

<pre><code class="language-bash line-numbers"># 1. You modify two files
echo "hello" &gt;&gt; a.txt
rm b.txt

# 2. You stage only one file
git add a.txt

# 3. You commit staged changes
git commit -m "Add hello to a.txt"
</code></pre>

    <br/>
    <ul>
        <li>Only <code>a.txt</code> enters the repository.</li>
        <li><code>b.txt</code> remains in the working directory as a deletion.</li>
    </ul>
    <br/><br/>


    <li><b>Visual Representation of the Stages</b></li>
<pre><code class="language-bash">Working Directory  --(git add)--&gt;  Staging Area  --(git commit)--&gt;  Repository</code></pre>
    <br/><br/>


    <li><b>Commands Related to Each Stage</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Stage</th>
                <th>Action</th>
                <th>Command</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Working Directory</td>
                <td>See changes</td>
                <td><code>git status</code></td>
            </tr>
            <tr>
                <td>Staging Area</td>
                <td>Add file to staging</td>
                <td><code>git add file</code></td>
            </tr>
            <tr>
                <td>Staging Area</td>
                <td>Unstage a file</td>
                <td><code>git restore --staged file</code></td>
            </tr>
            <tr>
                <td>Repository</td>
                <td>Commit staged changes</td>
                <td><code>git commit -m "message"</code></td>
            </tr>
            <tr>
                <td>Repository</td>
                <td>View history</td>
                <td><code>git log</code></td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>Undoing in Each Stage</b></li>
    <br/>
    <ul>
        <li><b>Undo changes in working directory</b></li>
    </ul>

<pre><code class="language-bash line-numbers">git restore file.txt
</code></pre>

    <ul>
        <li><b>Unstage a file</b></li>
    </ul>

<pre><code class="language-bash line-numbers">git restore --staged file.txt
</code></pre>

    <ul>
        <li><b>Undo the last commit (keep changes)</b></li>
    </ul>

<pre><code class="language-bash line-numbers">git reset --soft HEAD~1
</code></pre>

    <ul>
        <li><b>Undo the last commit (throw away changes)</b></li>
    </ul>

<pre><code class="language-bash line-numbers">git reset --hard HEAD~1
</code></pre>

    <br/><br/>


    <li><b>Summary of the Three Stages</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Stage</th>
                <th>State</th>
                <th>Command to Move Forward</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Working Directory</td>
                <td>Editing files</td>
                <td><code>git add</code></td>
            </tr>
            <tr>
                <td>Staging Area</td>
                <td>Preparing commit</td>
                <td><code>git commit</code></td>
            </tr>
            <tr>
                <td>Repository</td>
                <td>Stored history</td>
                <td><code>git push</code> (optional)</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="git-add-rm">Git Add and Git Rm</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>git add</code> and <code>git rm</code> are two fundamental commands used to manage which file changes are included in the next commit.</li>
        <br/>
        <li><code>git add</code> moves file changes from the <u>Working Directory</u> to the <u>Staging Area</u>.</li>
        <br/>
        <li><code>git rm</code> removes files from both the <u>Working Directory</u> and the <u>Staging Area</u>.</li>
    </ul>
    <br/><br/><br/>


    <li><b>Common git add Commands</b></li>
<pre><code class="language-bash line-numbers">git add .</code></pre>
    <ul>
        <li>Stages all changes in the current directory and subdirectories.</li>
    </ul>
    <br/>
    <br/>

<pre><code class="language-bash line-numbers">git add -A</code></pre>
    <ul>
        <li>Stage all changes in the repository (added, modified, deleted).</li>
    </ul>
    <br/>
    <br/>

<pre><code class="language-bash line-numbers">git add -p</code></pre>
    <ul>
        <li>Patch mode: interactively choose hunks to stage.</li>
        <li>Useful for creating clean, logical commits.</li>
    </ul>
    <br/>
    <br/>

<pre><code class="language-bash line-numbers">git add "*.txt"</code></pre>
    <ul>
        <li>Stages all <code>.txt</code> files using glob patterns.</li>
    </ul>
    <br/><br/><br/>


    <li><b>Staging Modified and Deleted Files</b></li>
<pre><code class="language-bash line-numbers">rm old.txt
git add old.txt
</code></pre>
    <ul>
        <li>If a file is removed manually via <code>rm</code>, <code>git add</code> stages the deletion.</li>
    </ul>
    <br/><br/><br/>


    <li><b>git rm: Remove Files from Git</b></li>
    <br/>
    <ul>
        <li><code>git rm</code> removes files from the Working Directory and the Staging Area</li>
        <li>Use it when you want to delete a file and record that deletion in your next commit.</li>
    </ul>

<pre><code class="language-bash line-numbers">git rm file.txt
</code></pre>

    <br/>
    <ul>
        <li>This does:
            <ul>
                <li>Deletes <code>file.txt</code> from disk</li>
                <li>Stages the deletion</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Common git rm Options</b></li>

<pre><code class="language-bash line-numbers">git rm --cached file.txt
</code></pre>
    <ul>
        <li>Removes file from Git but keeps the physical file on disk.</li>
        <li>Used when you accidentally commit something you want to keep locally (e.g., logs, environment files).</li>
    </ul>

<pre><code class="language-bash line-numbers">git rm -r docs/</code></pre>
    <ul>
        <li>Removes a directory recursively.</li>
    </ul>

<pre><code class="language-bash line-numbers">git rm -f file.txt</code></pre>
    <ul>
        <li>Forces removal, even if the file has modifications.</li>
        <li>Useful when file differs from last commit and Git blocks removal.</li>
    </ul>

    <br/><br/>


    <li><b>Workflow Examples</b></li>
    <br/>
    <ul>
        <li><b>Example 1: Add a new file</b></li>
    </ul>

<pre><code class="language-bash line-numbers">echo "hello" &gt; a.txt
git add a.txt
git commit -m "Add a.txt"
</code></pre>

    <br/>
    <ul>
        <li><b>Example 2: Delete a file using git rm</b></li>
    </ul>

<pre><code class="language-bash line-numbers">git rm old.txt
git commit -m "Remove old.txt"
</code></pre>

    <br/>
    <ul>
        <li><b>Example 3: Remove from Git, keep file on disk</b></li>
    </ul>

<pre><code class="language-bash line-numbers">git rm --cached secrets.env
echo "secrets.env" &gt;&gt; .gitignore
git commit -m "Stop tracking secrets.env"
</code></pre>

    <br/>
    <ul>
        <li><b>Example 4: Unstage a file added by mistake</b></li>
    </ul>

<pre><code class="language-bash line-numbers">git add largefile.zip
git restore --staged largefile.zip
</code></pre>

    <br/><br/>


    <li><b>Comparison Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Purpose</th>
                <th>Modifies Disk?</th>
                <th>Modifies Index?</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>git add file</code></td>
                <td>Stage file modifications</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><code>git add -A</code></td>
                <td>Stage all changes</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><code>git rm file</code></td>
                <td>Delete file, stage deletion</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td><code>git rm --cached file</code></td>
                <td>Remove from git, keep file</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
        </tbody>
    </table>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="git-stash">Git Stash</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>git stash</code> temporarily saves your uncommitted changes without creating a commit.</li>
        <br/>
        <li>Stashes are stored in a stack, and you can apply or inspect them later.</li>
    </ul>
    <br/><br/>


    <li><b>Basic Usage: Saving Changes</b></li>
<pre><code class="language-bash line-numbers">git stash
</code></pre>
    <br/>
    <ul>
        <li>Moves modified and staged changes into a stash entry.</li>
        <li>Resets your working directory to a clean state.</li>
    </ul>

<pre><code class="language-bash line-numbers">git stash save "WIP: working on login feature"
</code></pre>
    <br/>
    <ul>
        <li>Adds a message to identify the stash entry.</li>
    </ul>
    <br/><br/>


    <li><b>Saving Untracked Files</b></li>
<pre><code class="language-bash line-numbers">git stash -u
</code></pre>
    <ul>
        <li>Saves both tracked and untracked files.</li>
    </ul>
    <br/>

<pre><code class="language-bash line-numbers">git stash -a
</code></pre>
    <ul>
        <li>Saves <u>all</u> changes including ignored files.</li>
    </ul>
    <br/><br/>


    <li><b>Listing Stashes</b></li>
<pre><code class="language-bash line-numbers">git stash list
</code></pre>

<pre><code class="language-bash">stash@{0}: WIP on feature/login
stash@{1}: WIP: fixing UI
stash@{2}: WIP: initial setup
</code></pre>
    <br/>
    <ul>
        <li>Stashes are stored in a stack-like structure.</li>
    </ul>
    <br/><br/>


    <li><b>Applying Stashes</b></li>
<pre><code class="language-bash line-numbers">git stash apply
</code></pre>
    <ul>
        <li>Applies the most recent stash but <u>does not remove it</u> from the stash list.</li>
    </ul>
    <br/>

<pre><code class="language-bash line-numbers">git stash apply stash@{2}
</code></pre>
    <ul>
        <li>Applies a specific stash entry.</li>
    </ul>
    <br/><br/>


    <li><b>Applying and Removing a Stash (Pop)</b></li>
<pre><code class="language-bash line-numbers">git stash pop
</code></pre>
    <br/>
    <ul>
        <li>Applies the most recent stash and removes it from the list.</li>
        <li>Equivalent to: apply + remove</li>
    </ul>

<pre><code class="language-bash line-numbers">git stash pop stash@{1}
</code></pre>
    <br/><br/>


    <li><b>Dropping a Stash Entry</b></li>
<pre><code class="language-bash line-numbers">git stash drop stash@{0}
</code></pre>
    <ul>
        <li>Deletes a stash entry permanently.</li>
    </ul>
    <br/>

<pre><code class="language-bash line-numbers">git stash clear
</code></pre>
    <ul>
        <li>Deletes all stash entries.</li>
    </ul>
    <br/><br/>


    <li><b>Stashing Only Staged Changes</b></li>
<pre><code class="language-bash line-numbers">git stash --staged
</code></pre>
    <ul>
        <li>Saves only staged changes, leaving working directory untouched.</li>
    </ul>
    <br/><br/>


    <li><b>Stashing Only Specific Files</b></li>
<pre><code class="language-bash line-numbers">git stash -m "WIP: styling" css/style.css
</code></pre>
    <ul>
        <li>Stashes only the provided file(s).</li>
    </ul>
    <br/><br/>


    <li><b>Showing the Contents of a Stash</b></li>
<pre><code class="language-bash line-numbers">git stash show
</code></pre>
    <ul>
        <li>Shows which files were changed.</li>
    </ul>
    <br/>

<pre><code class="language-bash line-numbers">git stash show -p stash@{1}
</code></pre>
    <ul>
        <li>Shows the full diff patch.</li>
    </ul>
    <br/><br/>


    <li><b>Creating a Branch from a Stash</b></li>
<pre><code class="language-bash line-numbers">git stash branch feature/login-fix stash@{0}
</code></pre>
    <ul>
        <li>Creates a new branch with changes applied.</li>
        <li>Useful if the stash contains large or important work.</li>
        <li>Automatically drops the stash after application.</li>
    </ul>
    <br/><br/>


    <li><b>Handling Merge Conflicts During Pop/Apply</b></li>
<pre><code class="language-bash line-numbers">git stash pop
# conflict markers appear
</code></pre>

    <br/>
    <ul>
        <li>If conflicts appear:
            <ul>
                <li>resolve them manually</li>
                <li>then stage resolved files</li>
                <li>and commit or continue working</li>
            </ul>
        </li>
        <br/>
        <li><code>stash pop</code> will not delete the stash if conflicts occur.</li>
    </ul>
    <br/><br/>


    <li><b>Common Stash Workflow Examples</b></li>
    <br/>
    <ul>
        <li><b>Example 1: Save work, switch branch, restore</b></li>
    </ul>
<pre><code class="language-bash line-numbers">git stash
git switch main
git pull
git switch feature/login
git stash pop
</code></pre>

    <br/>
    <ul>
        <li><b>Example 2: Stashing new files</b></li>
    </ul>
<pre><code class="language-bash line-numbers">git stash -u
</code></pre>

    <br/>
    <ul>
        <li><b>Example 3: Stash one file only</b></li>
    </ul>
<pre><code class="language-bash line-numbers">git stash push -m "partial fix" app.js
</code></pre>

    <br/>
    <ul>
        <li><b>Example 4: Create a branch from a stash</b></li>
    </ul>
<pre><code class="language-bash line-numbers">git stash branch hotfix stash@{1}
</code></pre>

    <br/><br/>


    <li><b>Summary of git stash Commands</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>git stash</code></td>
                <td>Save tracked modified files</td>
            </tr>
            <tr>
                <td><code>git stash -u</code></td>
                <td>Save tracked + untracked files</td>
            </tr>
            <tr>
                <td><code>git stash apply</code></td>
                <td>Apply stash without removing</td>
            </tr>
            <tr>
                <td><code>git stash pop</code></td>
                <td>Apply and remove stash</td>
            </tr>
            <tr>
                <td><code>git stash list</code></td>
                <td>Show all stash entries</td>
            </tr>
            <tr>
                <td><code>git stash show -p</code></td>
                <td>Show stash diff</td>
            </tr>
            <tr>
                <td><code>git stash drop</code></td>
                <td>Delete one stash entry</td>
            </tr>
            <tr>
                <td><code>git stash clear</code></td>
                <td>Delete all stashes</td>
            </tr>
            <tr>
                <td><code>git stash branch name stash@{n}</code></td>
                <td>Create branch with stashed changes applied</td>
            </tr>
        </tbody>
    </table>
    <br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="git-merge">Git Merge</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>git merge</code> combines the history of one branch into another.</li>
        <br/>
        <li>Merging is <u>non-destructive</u>:
            <ul>
                <li>it does not rewrite commit history</li>
                <li>it creates a new commit (merge commit) when needed</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Basic Merge Example</b></li>
<pre><code class="language-bash line-numbers">git switch main
git merge feature/login
</code></pre>
    <br/>
    <ul>
        <li>This merges the <code>feature/login</code> branch into <code>main</code>.</li>
        <li>If no conflicts and histories diverged, Git creates a merge commit.</li>
    </ul>
    <br/><br/>


    <li><b>Fast-Forward Merge</b></li>
<pre><code class="language-bash line-numbers">git merge feature/ui
</code></pre>

    <br/>
    <ul>
        <li>If <code>main</code> has not diverged, Git simply moves the branch pointer forward.</li>
        <li>No merge commit is created.</li>
    </ul>

<pre><code class="language-bash"># Before:
main --- A --- B
             \
             (feature)

# After fast-forward merge:
main --- A --- B   (feature merged)
</code></pre>

    <br/><br/>


    <li><b>Forcing a Merge Commit (No Fast-Forward)</b></li>
<pre><code class="language-bash line-numbers">git merge --no-ff feature/login
</code></pre>
    <br/>
    <ul>
        <li>This forces Git to create a merge commit even if fast-forward is possible.</li>
        <li>Useful for:
            <ul>
                <li>Preserving branch history</li>
                <li>Code review traceability</li>
                <li>More readable merges</li>
            </ul>
        </li>
    </ul>
    <br/><br/>


    <li><b>Fast-Forward vs Merge Commit</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Git Behavior</th>
                <th>Usage</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Fast-forward</td>
                <td>Moves branch pointer; no merge commit</td>
                <td>Simple linear history</td>
            </tr>
            <tr>
                <td>Merge commit</td>
                <td>Creates a commit that joins histories</td>
                <td>Feature branch workflow</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>Checking Merge Status</b></li>
<pre><code class="language-bash line-numbers">git status
</code></pre>
    <ul>
        <li>Shows whether you are in the middle of a merge.</li>
    </ul>
    <br/>
<pre><code class="language-bash line-numbers">git log --oneline --graph --decorate
</code></pre>
    <ul>
        <li>Shows merge commits visually.</li>
    </ul>
    <br/><br/>


    <li><b>Merge Conflicts</b></li>
    <br/>
    <ul>
        <li>A conflict occurs when two branches modify the same part of a file.</li>
    </ul>

<pre><code class="language-bash line-numbers">git merge feature/login
# CONFLICT (content): Merge conflict in src/app.js
</code></pre>

    <br/>
    <ul>
        <li>Conflict markers appear inside the file:</li>
    </ul>

<pre><code class="language-bash line-numbers"><<<<<<< HEAD
current branch code
=======
incoming branch code
>>>>>>> feature/login
</code></pre>

    <br/>
    <ul>
        <li>To resolve conflicts:
            <ul>
                <li>edit the file</li>
                <li>remove conflict markers</li>
                <li>keep the correct version</li>
                <li>stage and commit</li>
            </ul>
        </li>
    </ul>

<pre><code class="language-bash line-numbers">git add src/app.js
git commit
</code></pre>

    <ul>
        <li>Git automatically creates the merge commit.</li>
    </ul>
    <br/><br/>


    <li><b>Aborting a Merge</b></li>
<pre><code class="language-bash line-numbers">git merge --abort
</code></pre>
    <ul>
        <li>Useful if merge goes wrong or conflicts are difficult to fix.</li>
        <li>Restores the repository to the state before merge began.</li>
    </ul>
    <br/><br/>


    <li><b>Squash Merging</b></li>
<pre><code class="language-bash line-numbers">git merge --squash feature/api
git commit -m "Add API feature"
</code></pre>
    <br/>
    <ul>
        <li>Combines all feature branch commits into a single commit.</li>
        <li>Does <u>not</u> retain branch history.</li>
        <li>Does <u>not</u> create a merge commit.</li>
    </ul>

    <br/><br/>


    <li><b>Merge vs Rebase (Conceptual)</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Operation</th>
                <th>Description</th>
                <th>History Style</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Merge</td>
                <td>Joins two histories with a merge commit</td>
                <td>Non-linear</td>
            </tr>
            <tr>
                <td>Rebase</td>
                <td>Replays your commits on top of another branch</td>
                <td>Linear</td>
            </tr>
        </tbody>
    </table>
    <br/>
    <ul>
        <li>Merging keeps branch structure, rebasing rewrites history.</li>
    </ul>
    <br/><br/>


    <li><b>Common Merge Workflow</b></li>
    <br/>
    <ul>
        <li><b>Example: Merge feature branch into main</b></li>
    </ul>
<pre><code class="language-bash line-numbers">git switch main
git pull
git merge feature/cart
git push
</code></pre>

    <br/>
    <ul>
        <li><b>Example: Bring latest main changes into feature branch</b></li>
    </ul>
<pre><code class="language-bash line-numbers">git switch feature/cart
git merge main
</code></pre>

    <br/>
    <ul>
        <li><b>Example: Merge without fast-forward</b></li>
    </ul>
<pre><code class="language-bash line-numbers">git merge --no-ff feature/cart
</code></pre>

    <br/><br/>


    <li><b>Summary of Git Merge Options</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>git merge branch</code></td>
                <td>Merge branch into current branch</td>
            </tr>
            <tr>
                <td><code>git merge --no-ff branch</code></td>
                <td>Force merge commit even if fast-forward is possible</td>
            </tr>
            <tr>
                <td><code>git merge --squash branch</code></td>
                <td>Merge changes as one commit (no merge commit)</td>
            </tr>
            <tr>
                <td><code>git merge --abort</code></td>
                <td>Cancel merge and restore previous state</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="git-fetch-pull">Git Fetch vs Git Pull</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>Both <code>git fetch</code> and <code>git pull</code> are used to get changes from a remote repository (e.g., GitHub) into your local repository.</li>
        <br/>
        <li>The key difference:</li>
        <ul>
            <li><code>git fetch</code> <u>only downloads</u> changes from remote; it does <u>not</u> modify your current branch.</li>
            <li><code>git pull</code> downloads changes <u>and immediately integrates</u> them into your current branch (via merge or rebase).</li>
        </ul>
    </ul>
    <br/><br/>


    <li><b>How Git Stores Remote Changes</b></li>
    <br/>
    <ul>
        <li>When working with remotes, Git uses <u>remote-tracking branches</u>, such as:</li>
        <ul>
            <li><code>origin/main</code></li>
            <li><code>origin/feature/login</code></li>
        </ul>
        <br/>
        <li>Your local branch (e.g. <code>main</code>) usually <u>tracks</u> a remote branch (e.g. <code>origin/main</code>).</li>
        <br/>
        <li><code>git fetch</code> updates these remote-tracking branches.</li>
        <li><code>git pull</code> updates them <u>and</u> tries to bring your current branch up to date as well.</li>
    </ul>
    <br/><br/>


    <li><b>git fetch: Download Only</b></li>
    <br/>
    <ul>
        <li>Fetch changes from the default remote (<code>origin</code>):</li>
    </ul>

<pre><code class="language-bash line-numbers">git fetch
</code></pre>

    <ul>
        <li>Fetch from a specific remote and branch:</li>
    </ul>

<pre><code class="language-bash line-numbers">git fetch origin main
</code></pre>

    <br/>
    <ul>
        <li>What happens after <code>git fetch</code>:</li>
        <ul>
            <li>New commits are downloaded to your local <code>.git</code> database.</li>
            <li>Remote-tracking branches like <code>origin/main</code> are updated.</li>
            <li>Your current branch (e.g. <code>main</code>) remains unchanged.</li>
        </ul>
        <br/>
        <li>You can now inspect the changes <u>before</u> merging:</li>
    </ul>

<pre><code class="language-bash line-numbers">git log HEAD..origin/main --oneline
git diff HEAD..origin/main
</code></pre>

    <br/>
    <ul>
        <li>Typical usage: safe way to see what others pushed without touching your working tree.</li>
    </ul>
    <br/><br/>


    <li><b>git pull: Fetch + Integrate</b></li>
    <br/>
    <ul>
        <li><code>git pull</code> is essentially:</li>
    </ul>

<pre><code class="language-bash line-numbers">git fetch
git merge origin/&lt;your-branch&gt;
</code></pre>

    <br/>
    <ul>
        <li>Basic usage:</li>
    </ul>

<pre><code class="language-bash line-numbers">git pull
</code></pre>

    <ul>
        <li>If your current branch tracks <code>origin/main</code>:</li>
        <ul>
            <li>Git fetches new commits from <code>origin</code>.</li>
            <li>Then merges <code>origin/main</code> into your local <code>main</code>.</li>
            <li>This may create a merge commit or cause merge conflicts.</li>
        </ul>
    </ul>
    <br/>

    <ul>
        <li>You can also tell Git to rebase instead of merge:</li>
    </ul>

<pre><code class="language-bash line-numbers">git pull --rebase
</code></pre>

    <ul>
        <li>This is roughly:</li>
    </ul>

<pre><code class="language-bash line-numbers">git fetch
git rebase origin/&lt;your-branch&gt;
</code></pre>

    <br/>
    <ul>
        <li>Typical usage: quickly bring your branch up to date when you are comfortable with merge/rebase happening immediately.</li>
    </ul>
    <br/><br/>


    <li><b>Step-by-Step Comparison</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Aspect</th>
                <th><code>git fetch</code></th>
                <th><code>git pull</code></th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Updates remote-tracking branches?</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Updates current local branch?</td>
                <td>No</td>
                <td>Yes (merge or rebase)</td>
            </tr>
            <tr>
                <td>Risk of merge conflicts right away?</td>
                <td>No (nothing merged yet)</td>
                <td>Yes (integration happens immediately)</td>
            </tr>
            <tr>
                <td>Good for reviewing incoming changes?</td>
                <td>Excellent</td>
                <td>Possible, but history already changed</td>
            </tr>
            <tr>
                <td>Typical use case</td>
                <td>Inspect, compare, then decide how to merge</td>
                <td>Fast update to latest remote state</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>


    <li><b>Example: Using git fetch for Safe Updates</b></li>
    <br/>
<pre><code class="language-bash line-numbers"># 1. Download changes only
git fetch origin

# 2. See what changed on origin/main
git log HEAD..origin/main --oneline

# 3. Merge (or rebase) when you're ready
git merge origin/main
# or
git rebase origin/main
</code></pre>

    <br/>
    <ul>
        <li>Advantages:</li>
        <ul>
            <li>You stay in control of when and how history is integrated.</li>
            <li>You can avoid surprises or conflicts while you are in the middle of work.</li>
        </ul>
    </ul>
    <br/><br/>


    <li><b>Example: Quick Update with git pull</b></li>
    <br/>
<pre><code class="language-bash line-numbers"># On branch main, tracking origin/main
git pull
</code></pre>

    <br/>
    <ul>
        <li>If there are no conflicts, your <code>main</code> is now at the same commit as <code>origin/main</code>.</li>
        <br/>
        <li>For linear history lovers:</li>
    </ul>

<pre><code class="language-bash line-numbers">git pull --rebase
</code></pre>

    <ul>
        <li>This rewrites your local commits on top of the latest remote commits.</li>
    </ul>
    <br/><br/>


    <li><b>When to Use Which?</b></li>
    <br/>
    <ul>
        <li>Prefer <code>git fetch</code> when:</li>
        <ul>
            <li>You want to review incoming changes before integrating.</li>
            <li>You are in the middle of something and do not want merge conflicts now.</li>
            <li>You are debugging or inspecting remote history.</li>
        </ul>
        <br/>
        <li>Prefer <code>git pull</code> when:</li>
        <ul>
            <li>You simply want your branch up to date with the remote.</li>
            <li>You are okay with Git performing merge or rebase automatically.</li>
            <li>You are in a clean working state (no uncommitted local changes).</li>
        </ul>
    </ul>
    <br/><br/>


    <li><b>Common Aliases and Configs</b></li>
    <br/>
    <ul>
        <li>Some people configure Git to always rebase on pull:</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global pull.rebase true
</code></pre>

    <ul>
        <li>Or define aliases to remind themselves of the difference:</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global alias.fp "fetch --prune"
git config --global alias.pl "pull --rebase"
</code></pre>

    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>What it does</th>
                <th>Mental Model</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>git fetch</code></td>
                <td>Download changes from remote, update <code>origin/*</code> branches, leave your current branch untouched.</td>
                <td>"Update my knowledge of the remote, but do not touch my work."</td>
            </tr>
            <tr>
                <td><code>git pull</code></td>
                <td>Fetch changes and immediately integrate them into the current branch by merge or rebase.</td>
                <td>"Download and merge now."</td>
            </tr>
        </tbody>
    </table>
    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="git-remote">Git Remote</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li>A <code>remote</code> in Git is a reference (a named pointer) to another repository, usually hosted online (e.g., GitHub, GitLab, Bitbucket).</li>
        <br/>
        <li>Remotes let your local repository communicate by:</li>
        <ul>
            <li>fetching new commits</li>
            <li>pushing your commits</li>
            <li>tracking branches on the remote server</li>
        </ul>
        <br/>
        <li>The default remote is usually named <code>origin</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Viewing Existing Remotes</b></li>
    <br/>
<pre><code class="language-bash line-numbers">git remote
</code></pre>

    <ul>
        <li>Shows remote names only.</li>
    </ul>

<pre><code class="language-bash line-numbers">git remote -v
</code></pre>

    <ul>
        <li>Shows remote names and their URLs (fetch + push URLs).</li>
    </ul>

<pre><code class="language-bash">origin  https://github.com/user/repo.git (fetch)
origin  https://github.com/user/repo.git (push)
</code></pre>

    <br/><br/>


    <li><b>Adding a Remote</b></li>
    <br/>
    <ul>
        <li>Add a remote repository named <code>origin</code>:</li>
    </ul>

<pre><code class="language-bash line-numbers">git remote add origin https://github.com/user/repo.git
</code></pre>

    <ul>
        <li>Common use when:</li>
        <ul>
            <li>You cloned from local folder and want to connect it online.</li>
            <li>You want to work with multiple remotes.</li>
        </ul>
    </ul>
    <br/><br/>


    <li><b>Removing a Remote</b></li>
    <br/>
<pre><code class="language-bash line-numbers">git remote remove origin
</code></pre>

    <ul>
        <li>Deletes the reference to the remote repository.</li>
        <li>This does <u>not</u> delete local branches or commits.</li>
    </ul>

<pre><code class="language-bash line-numbers">git remote rm origin
</code></pre>

    <ul>
        <li>Alias for the same action.</li>
    </ul>
    <br/><br/>


    <li><b>Renaming a Remote</b></li>
    <br/>
<pre><code class="language-bash line-numbers">git remote rename origin upstream
</code></pre>

    <ul>
        <li>Useful when working with forked repositories:</li>
    </ul>
    <br/><br/>


    <li><b>Changing the URL of a Remote</b></li>
    <br/>
<pre><code class="language-bash line-numbers">git remote set-url origin https://github.com/newuser/newrepo.git
</code></pre>

    <ul>
        <li>Required when:</li>
        <ul>
            <li>You renamed your GitHub repository.</li>
            <li>You changed HTTPS → SSH or vice versa.</li>
        </ul>
    </ul>

<pre><code class="language-bash line-numbers">git remote set-url origin git@github.com:user/repo.git
</code></pre>

    <br/><br/>


    <li><b>Fetching From a Remote</b></li>
    <br/>
    <ul>
        <li>Fetch all remotes:</li>
    </ul>

<pre><code class="language-bash line-numbers">git fetch
</code></pre>

    <ul>
        <li>Fetch from a specific remote:</li>
    </ul>

<pre><code class="language-bash line-numbers">git fetch origin
</code></pre>

    <ul>
        <li>This updates remote-tracking branches (e.g. <code>origin/main</code>) but does NOT touch your local branches.</li>
    </ul>
    <br/><br/>


    <li><b>Pushing to a Remote</b></li>
    <br/>
<pre><code class="language-bash line-numbers">git push origin main
</code></pre>

    <ul>
        <li>Pushes your local <code>main</code> branch to <code>origin/main</code>.</li>
    </ul>

<pre><code class="language-bash line-numbers">git push -u origin feature/api
</code></pre>

    <ul>
        <li>Creates the branch on the remote and sets upstream tracking.</li>
    </ul>
    <br/><br/>


    <li><b>Inspecting a Remote in Detail</b></li>
    <br/>
<pre><code class="language-bash line-numbers">git remote show origin
</code></pre>

    <ul>
        <li>This displays:</li>
        <ul>
            <li>Remote URL</li>
            <li>Tracked branches</li>
            <li>Local→remote branch relationships</li>
            <li>Push &amp; fetch configuration</li>
        </ul>
    </ul>

<pre><code class="language-bash">
* remote origin
  Fetch URL: https://github.com/user/repo.git
  Push  URL: https://github.com/user/repo.git
  HEAD branch: main
  Local branches configured for 'git pull':
    main merges with remote main
</code></pre>

    <br/><br/>


    <li><b>Working With Multiple Remotes</b></li>
    <br/>
    <ul>
        <li>You can have more than one remote:</li>
        <ul>
            <li><code>origin</code> → your GitHub repo</li>
            <li><code>upstream</code> → original project</li>
            <li><code>backup</code> → a mirrored backup</li>
        </ul>
        <br/>
        <li>Add upstream:</li>
    </ul>

<pre><code class="language-bash line-numbers">git remote add upstream https://github.com/original/project.git
</code></pre>

    <ul>
        <li>Fetch upstream’s changes:</li>
    </ul>

<pre><code class="language-bash line-numbers">git fetch upstream
</code></pre>

    <ul>
        <li>Merge upstream into your main branch:</li>
    </ul>

<pre><code class="language-bash line-numbers">git merge upstream/main
</code></pre>

    <br/><br/>


    <li><b>Removing Orphaned Remote Branch References</b></li>
    <br/>
    <ul>
        <li>If a branch was deleted on the remote, your local <code>origin/branch</code> reference remains until cleanup.</li>
    </ul>

<pre><code class="language-bash line-numbers">git fetch --prune
</code></pre>

    <ul>
        <li>This removes remote-tracking branches that no longer exist on the server.</li>
    </ul>
    <br/><br/>


    <li><b>Summary Table</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>git remote -v</code></td>
                <td>Show all remotes with their URLs.</td>
            </tr>
            <tr>
                <td><code>git remote add name url</code></td>
                <td>Add a new remote.</td>
            </tr>
            <tr>
                <td><code>git remote remove name</code></td>
                <td>Remove an existing remote.</td>
            </tr>
            <tr>
                <td><code>git remote rename old new</code></td>
                <td>Rename a remote.</td>
            </tr>
            <tr>
                <td><code>git remote set-url name url</code></td>
                <td>Change the URL of a remote.</td>
            </tr>
            <tr>
                <td><code>git remote show name</code></td>
                <td>Inspect remote details.</td>
            </tr>
            <tr>
                <td><code>git fetch name</code></td>
                <td>Download new commits from the remote.</td>
            </tr>
            <tr>
                <td><code>git push name branch</code></td>
                <td>Upload local commits to the remote.</td>
            </tr>
            <tr>
                <td><code>git fetch --prune</code></td>
                <td>Remove stale remote-tracking branches.</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->
<h3 id="git-config">Git Config</h3>
<ol>
    <li><b>Introduction</b></li>
    <br/>
    <ul>
        <li><code>git config</code> is the command used to view, edit, and manage Git configuration settings.</li>
        <br/>
        <li>These settings control Git’s behavior, identity, colors, default editor, merge tool, aliases, and much more.</li>
        <br/>
        <li>Git has 3 levels of configuration:</li>
        <ul>
            <li><b>System</b>: applies to all users on the system (e.g., <code>/etc/gitconfig</code>)</li>
            <li><b>Global</b>: applies to the current user (e.g., <code>~/.gitconfig</code>)</li>
            <li><b>Local</b>: applies only to the current repository (<code>.git/config</code>)</li>
        </ul>
        <br/>
        <li>Configuration levels override each other in this order:</li>
        <ul>
            <li>Local &gt; Global &gt; System</li>
        </ul>
    </ul>
    <br/><br/>


    <li><b>Viewing Configuration</b></li>
    <br/>
<pre><code class="language-bash line-numbers">git config --list
</code></pre>

    <ul>
        <li>Displays all configuration values Git sees (local + global + system).</li>
        <br/>
    </ul>

<pre><code class="language-bash line-numbers">git config --global --list
</code></pre>

    <ul>
        <li>Shows only global-level config.</li>
        <br/>
    </ul>

<pre><code class="language-bash line-numbers">git config --get user.name
</code></pre>

    <ul>
        <li>Shows a specific configuration value.</li>
        <br/>
    </ul>

<pre><code class="language-bash line-numbers">git config --show-origin user.email
</code></pre>

    <ul>
        <li>Shows where a setting came from (useful for debugging).</li>
    </ul>
    <br/><br/><br/>


    <li><b>Setting Up Identity</b></li>
    <br/>
    <ul>
        <li>These must be set before making commits:</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global user.name "Your Name"
git config --global user.email "username@example.com"
</code></pre>

    <ul>
        <li>The <code>--global</code> flag writes to <code>~/.gitconfig</code>.</li>
    </ul>

<pre><code class="language-bash line-numbers">git config user.name "Local Repo Name"
</code></pre>

    <ul>
        <li>Sets identity only for the current repository.</li>
    </ul>
    <br/><br/>


    <li><b>Editing Configuration Files Directly</b></li>
    <br/>
<pre><code class="language-bash line-numbers">git config --global --edit
</code></pre>

    <ul>
        <li>Opens <code>~/.gitconfig</code> in your default editor.</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --local --edit
</code></pre>

    <ul>
        <li>Opens <code>.git/config</code> in the current project.</li>
    </ul>
    <br/><br/>


    <li><b>Configuring the Default Editor</b></li>
    <br/>
<pre><code class="language-bash line-numbers">git config --global core.editor "nvim"
</code></pre>

    <ul>
        <li>Sets the editor used for commit messages and merges.</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global core.editor "code --wait"
</code></pre>

    <ul>
        <li>VS Code example: waits until the window closes.</li>
    </ul>
    <br/><br/>


    <li><b>Configuring Default Branch Name</b></li>
    <br/>
<pre><code class="language-bash line-numbers">git config --global init.defaultBranch main
</code></pre>

    <ul>
        <li>Ensures newly created repos use <code>main</code> instead of <code>master</code>.</li>
    </ul>
    <br/><br/>


    <li><b>Configuring Line Endings</b></li>
    <br/>

<pre><code class="language-bash line-numbers">git config --global core.autocrlf input
</code></pre>

    <ul>
        <li><code>input</code> – convert CRLF to LF on commit (recommended for macOS/Linux).</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global core.autocrlf true
</code></pre>

    <ul>
        <li><code>true</code> – checkout CRLF, commit LF (for Windows).</li>
    </ul>
    <br/><br/>


    <li><b>Aliases: Custom Git Commands</b></li>
    <br/>
    <ul>
        <li>Aliases shorten long commands:</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global alias.st "status"
git config --global alias.co "checkout"
git config --global alias.br "branch"
git config --global alias.ci "commit"
</code></pre>

    <ul>
        <li>Complex example:</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global alias.lg "log --oneline --graph --decorate --all"
</code></pre>

    <br/>
    <ul>
        <li>Using it:</li>
    </ul>

<pre><code class="language-bash line-numbers">git lg
</code></pre>

    <br/><br/>


    <li><b>Configuring Merge & Diff Tools</b></li>
    <br/>
    <ul>
        <li>To use an external merge tool:</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global merge.tool vimdiff
git config --global mergetool.keepBackup false
</code></pre>

    <ul>
        <li>To set diff tool (example: VS Code):</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global diff.tool vscode
git config --global difftool.vscode.cmd "code --wait --diff $LOCAL $REMOTE"
</code></pre>

    <br/><br/>


    <li><b>Configure Pull Behavior (Merge vs Rebase)</b></li>
    <br/>

<pre><code class="language-bash line-numbers">git config --global pull.rebase false
</code></pre>

    <ul>
        <li>Default: merge on pull.</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global pull.rebase true
</code></pre>

    <ul>
        <li>Use rebase instead of merge for <code>git pull</code>.</li>
    </ul>

    <br/><br/>


    <li><b>Configuring Push Behavior</b></li>
    <br/>
    <ul>
        <li>Push only the current branch (recommended modern behavior):</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global push.default current
</code></pre>

    <ul>
        <li>Other options:</li>
        <ul>
            <li><code>simple</code> – safe default</li>
            <li><code>upstream</code> – push to the upstream branch</li>
            <li><code>matching</code> – push all matching branch names (dangerous)</li>
        </ul>
    </ul>
    <br/><br/>


    <li><b>Enabling Colored Output</b></li>
    <br/>

<pre><code class="language-bash line-numbers">git config --global color.ui auto
</code></pre>

    <ul>
        <li>Makes Git output more readable with colors.</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global color.diff auto
git config --global color.status auto
git config --global color.branch auto
</code></pre>

    <br/><br/>


    <li><b>Configuring Credential Caching</b></li>
    <br/>
    <ul>
        <li>Cache credentials temporarily:</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global credential.helper cache
</code></pre>

    <ul>
        <li>Cache for 1 hour:</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global credential.helper "cache --timeout=3600"
</code></pre>

    <br/>
    <ul>
        <li>Store credentials permanently (not recommended):</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global credential.helper store
</code></pre>

    <br/><br/>


    <li><b>Configuring HTTPS vs SSH</b></li>
    <br/>
    <ul>
        <li>Force Git to use SSH:</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --global url."ssh://git@github.com/".insteadOf "https://github.com/"
</code></pre>

    <ul>
        <li>Now any HTTPS GitHub URL automatically becomes SSH.</li>
    </ul>
    <br/><br/>


    <li><b>Unsetting (Removing) a Config Value</b></li>
    <br/>

<pre><code class="language-bash line-numbers">git config --global --unset user.email
</code></pre>

    <ul>
        <li>Removes the value from the config file.</li>
    </ul>

<pre><code class="language-bash line-numbers">git config --unset-all alias.lg
</code></pre>

    <ul>
        <li>Removes all entries with that name.</li>
    </ul>
    <br/><br/>


    <li><b>Summary</b></li>
    <br/>
    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>git config --list</code></td>
                <td>View all effective config values.</td>
            </tr>
            <tr>
                <td><code>git config --global user.name</code></td>
                <td>Set username globally.</td>
            </tr>
            <tr>
                <td><code>git config --edit</code></td>
                <td>Edit config file using editor.</td>
            </tr>
            <tr>
                <td><code>git config --global alias.xxx</code></td>
                <td>Create a custom shorthand command.</td>
            </tr>
            <tr>
                <td><code>git config --global core.editor</code></td>
                <td>Set default editor.</td>
            </tr>
            <tr>
                <td><code>git config --global pull.rebase true</code></td>
                <td>Make <code>git pull</code> use rebase by default.</td>
            </tr>
            <tr>
                <td><code>git config --unset key</code></td>
                <td>Remove a config value.</td>
            </tr>
            <tr>
                <td><code>git config --show-origin key</code></td>
                <td>Show where config was defined.</td>
            </tr>
        </tbody>
    </table>

    <br/><br/>
</ol>
<br/>
<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>


<!-- * * * * * * * * * * * * * * -->

<!-- * * * * * * * * * * * * * * -->


<hr/>
